<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Voltage & Current Monitor</title>
  <style>
    body {
      margin: 0;
      padding: 30px;
      background: transparent;
      font-family: 'Consolas', monospace;
      color: #ccc;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .grid {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.1;
      background-image: 
        linear-gradient(rgba(100, 100, 150, 0.3) 1px, transparent 1px),
        linear-gradient(90deg, rgba(100, 100, 150, 0.3) 1px, transparent 1px);
      background-size: 30px 30px;
      z-index: -1;
    }

    .description-section {
      background: rgba(50, 50, 70, 0.85);
      border: 1px solid #4a4a6a;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 30px;
      width: 1200px;
      box-shadow: 0 0 10px rgba(100, 100, 200, 0.2);
      backdrop-filter: blur(5px);
      text-align: center;
      position: relative;
    }

    .description-title {
      font-size: 18px;
      color: #ffcc00;
      margin-bottom: 10px;
    }

    .description-divider {
      border: none;
      border-bottom: 2px dashed #ffcc00;
      margin: 10px 0;
    }

    .description-text {
      font-size: 16px;
      color: #ccc;
      line-height: 1.5;
    }

    .controls-container {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(30, 30, 45, 0.9);
      border: 1px solid #555;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 0 10px rgba(100, 100, 200, 0.3);
      backdrop-filter: blur(5px);
    }

    .controls-row {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .control-button {
      background: rgba(50, 50, 70, 0.8);
      border: 1px solid #666;
      border-radius: 6px;
      padding: 10px 20px;
      color: #ccc;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: inherit;
      font-size: 12px;
      width: 100%;
      text-align: center;
    }

    .control-button:hover {
      background: rgba(50, 50, 70, 0.8);
      border-color: #00ff88;
    }

    .control-button.active {
      background: rgba(0, 255, 136, 0.2);
      border-color: #00ff88;
      color: #00ff88;
    }

    .monitors-container {
      display: flex;
      gap: 30px;
      width: 1200px;
      justify-content: space-between;
    }

    .monitor-section {
      background: rgba(40, 40, 60, 0.85);
      border: 1px solid #4a4a6a;
      border-radius: 10px;
      padding: 30px;
      width: 48%;
      box-shadow: 0 0 10px rgba(100, 100, 200, 0.2);
      backdrop-filter: blur(5px);
    }

    .section-title {
      font-size: 20px;
      color: rgba(255, 204, 0, 0.99);
      margin-bottom: 20px;
      border-bottom: 2px dashed #ffcc00;
      padding-bottom: 8px;
      text-align: center;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .value-display {
      font-size: 16px;
      color: #ffcc00;
      font-weight: bold;
    }

    .chart-container {
      position: relative;
      height: 300px;
      width: 96%;
      background: rgba(20, 20, 30, 0.8);
      border: 1px solid #555;
      border-radius: 8px;
      padding: 20px;
    }

    .status-info {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
      font-size: 12px;
      color: #aaa;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff3333;
      transition: all 0.3s ease;
    }

    .status-indicator.connected {
      background: #00ff88;
      box-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      margin-top: 15px;
    }

    .stat-item {
      background: rgba(30, 30, 45, 0.7);
      border: 1px solid #555;
      border-radius: 6px;
      padding: 10px;
      text-align: center;
    }

    .stat-label {
      font-size: 11px;
      color: #888;
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 14px;
      font-weight: bold;
    }

    .voltage-theme .stat-value {
      color: #ff6b6b;
    }

    .current-theme .stat-value {
      color: #4ecdc4;
    }
  </style>
</head>
<body>
  <div class="grid"></div>

  <!-- Description Section with Controls -->
  <div class="description-section">
    <div class="controls-container">
      <div class="controls-row">
        <button class="control-button" id="pause-btn">Pause</button>
        <button class="control-button" id="reset-btn">Reset</button>
        <button class="control-button" id="export-json-btn">Export JSON</button>
        <button class="control-button" id="export-csv-btn">Export CSV</button>
      </div>
    </div>
    <h2 class="description-title">Dashboard Overview</h2>
    <hr class="description-divider">
    <p class="description-text">
      This dashboard provides real-time monitoring of voltage and current values. The graphs below display the instantaneous, average, and peak values for both voltage and current sensors. Use the controls to pause, reset, or export the data.
    </p>
  </div>

  <!-- Monitors Container -->
  <div class="monitors-container" id="monitors-container">
    <!-- Sections will be generated dynamically by JavaScript -->
  </div>

  <!-- Include Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Include Socket.IO -->
  <script src="https://cdn.socket.io/4.3.2/socket.io.min.js"></script>
  
  <script>
    // Monitor configuration - Add new monitors here easily
    const monitorConfigs = [
      {
        id: 'voltage',
        label: 'Voltage Monitor',
        unit: 'V',
        theme: 'voltage-theme',
        color: '#ff6b6b',
        backgroundColor: 'rgba(255, 107, 107, 0.1)'
      },
      {
        id: 'current',
        label: 'Current Monitor', 
        unit: 'A',
        theme: 'current-theme',
        color: '#4ecdc4',
        backgroundColor: 'rgba(78, 205, 196, 0.1)'
      }
    ];
    
    // Data storage
    const maxDataPoints = 1000;
    let monitorData = {};
    let monitorStats = {};
    let charts = {};
    let elements = {};
    let isPaused = false;
    
    // Initialize data structures for each monitor
    monitorConfigs.forEach(config => {
      monitorData[config.id] = [];
      monitorStats[config.id] = { sum: 0, count: 0, peak: 0 };
    });

    // Function to create a monitor section
    function createMonitorSection(config) {
      return `
        <div class="monitor-section ${config.theme}">
          <div class="section-title">
            <span>${config.label}</span>
            <div class="value-display" id="${config.id}-current">0.00 ${config.unit}</div>
          </div>
          
          <div class="chart-container">
            <canvas id="${config.id}Chart"></canvas>
          </div>

          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-label">Current</div>
              <div class="stat-value" id="${config.id}-instantaneous">0.00 ${config.unit}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Average</div>
              <div class="stat-value" id="${config.id}-average">0.00 ${config.unit}</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">Peak</div>
              <div class="stat-value" id="${config.id}-peak">0.00 ${config.unit}</div>
            </div>
          </div>

          <div class="status-info">
            <div class="connection-status">
              <div class="status-indicator" id="${config.id}-status"></div>
              <span>${config.label.replace(' Monitor', ' Sensor')}</span>
            </div>
            <span>Samples: <span id="${config.id}-samples">0</span></span>
          </div>
        </div>
      `;
    }

    // Generate monitor sections dynamically
    function initializeMonitors() {
      const container = document.getElementById('monitors-container');
      container.innerHTML = monitorConfigs.map(createMonitorSection).join('');
      
      // Cache DOM elements for each monitor
      monitorConfigs.forEach(config => {
        elements[config.id] = {
          current: document.getElementById(`${config.id}-current`),
          instantaneous: document.getElementById(`${config.id}-instantaneous`),
          average: document.getElementById(`${config.id}-average`),
          peak: document.getElementById(`${config.id}-peak`),
          samples: document.getElementById(`${config.id}-samples`),
          status: document.getElementById(`${config.id}-status`)
        };
      });
    }
    
    // Data storage - keeping legacy variable names for compatibility
    let voltageData = [];
    let currentData = [];
    let timeLabels = [];
    
    // Statistics tracking - keeping legacy variable names for compatibility  
    let voltageStats = { sum: 0, count: 0, peak: 0 };
    let currentStats = { sum: 0, count: 0, peak: 0 };

    // Chart configuration template
    const chartConfig = {
      type: 'line',
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        scales: {
          x: {
            type: 'linear',
            position: 'bottom',
            grid: {
              color: 'rgba(255, 255, 255, 0.1)'
            },
            ticks: {
              color: '#888',
              callback: function(value) {
                return value.toFixed(1) + 's';
              }
            }
          },
          y: {
            grid: {
              color: 'rgba(255, 255, 255, 0.1)'
            },
            ticks: {
              color: '#888'
            }
          }
        },
        plugins: {
          legend: {
            display: false
          }
        },
        elements: {
          point: {
            radius: 0
          },
          line: {
            tension: 0.1
          }
        }
      }
    };

    // Initialize charts for each monitor
    function initializeCharts() {
      monitorConfigs.forEach(config => {
        charts[config.id] = new Chart(document.getElementById(`${config.id}Chart`), {
          ...chartConfig,
          data: {
            datasets: [{
              label: config.label,
              data: [],
              borderColor: config.color,
              backgroundColor: config.backgroundColor,
              borderWidth: 2,
              fill: true
            }]
          }
        });
      });
    }

    // Legacy chart variables for compatibility
    let voltageChart, currentChart;

    // Generic update statistics function
    function updateStats(value, type) {
      const config = monitorConfigs.find(c => c.id === type);
      if (!config) return;
      
      const stats = monitorStats[type];
      stats.sum += value;
      stats.count++;
      stats.peak = Math.max(stats.peak, Math.abs(value));
      
      const average = stats.sum / stats.count;
      const suffix = ` ${config.unit}`;
      
      elements[type].instantaneous.textContent = value.toFixed(2) + suffix;
      elements[type].average.textContent = average.toFixed(2) + suffix;
      elements[type].peak.textContent = stats.peak.toFixed(2) + suffix;
      elements[type].samples.textContent = stats.count.toString();
      elements[type].current.textContent = value.toFixed(2) + suffix;
      
      // Update legacy stats for compatibility
      if (type === 'voltage') {
        voltageStats = stats;
      } else if (type === 'current') {
        currentStats = stats;
      }
    }

    // Add data point
    function addDataPoint(timestamp, voltage, current) {
      if (isPaused) return;

      const timeInSeconds = timestamp / 1000;
      
      // Add new data
      voltageData.push({ x: timeInSeconds, y: voltage });
      currentData.push({ x: timeInSeconds, y: current });
      
      // Remove old data if exceeding max points
      if (voltageData.length > maxDataPoints) {
        voltageData.shift();
        currentData.shift();
      }
      
      // Update charts using the new chart structure
      charts.voltage.data.datasets[0].data = voltageData;
      charts.current.data.datasets[0].data = currentData;
      
      charts.voltage.update('none');
      charts.current.update('none');
      
      // Update legacy chart references for compatibility
      voltageChart = charts.voltage;
      currentChart = charts.current;
      
      // Update statistics
      updateStats(voltage, 'voltage');
      updateStats(current, 'current');
      
      // Update connection status indicators
      updateConnectionStatus();
    }

    // Update connection status
    function updateConnectionStatus() {
      monitorConfigs.forEach(config => {
        elements[config.id].status.classList.add('connected');
      });
    }

    // Initialize everything when page loads
    document.addEventListener('DOMContentLoaded', function() {
      initializeMonitors();
      initializeCharts();
      
      // Set legacy chart references for compatibility
      voltageChart = charts.voltage;
      currentChart = charts.current;
    });

    // Socket.IO Handle
    const socket = io();

    socket.on('connect', function() {
      console.log('Connected to server');
      updateConnectionStatus();
    });
    
    socket.on('disconnect', function() {
      console.log('Disconnected from server');
      monitorConfigs.forEach(config => {
        if (elements[config.id]) {
          elements[config.id].status.classList.remove('connected');
        }
      });
    });

    /*
    // Handle sensor data (both voltage and current together)
    
    socket.on('sensor_data', function(data) {
      const voltage = parseFloat(data.voltage || 0);
      const current = parseFloat(data.current || 0);
      const timestamp = data.timestamp || Date.now();
      
      addDataPoint(timestamp, voltage, current);
    });
    */
    
    // Handle individual voltage data
    socket.on('voltage_data', function(data) {
      const voltage = parseFloat(data.value || 0);
      const timestamp = data.timestamp || Date.now();
      // If we don't have recent current data, use the last known value or 0
      const lastCurrent = currentData.length > 0 ? currentData[currentData.length - 1].y : 0;
      addDataPoint(timestamp, voltage, lastCurrent);
    });

    // Handle individual current data
    socket.on('current_data', function(data) {
      const current = parseFloat(data.value || 0);
      const timestamp = data.timestamp || Date.now();
      // If we don't have recent voltage data, use the last known value or 0
      const lastVoltage = voltageData.length > 0 ? voltageData[voltageData.length - 1].y : 0;
      addDataPoint(timestamp, lastVoltage, current);
    });

    // Control buttons
    document.getElementById('pause-btn').addEventListener('click', function() {
      isPaused = !isPaused;
      this.textContent = isPaused ? 'Resume' : 'Pause';
      this.classList.toggle('active', isPaused);
    });

    document.getElementById('reset-btn').addEventListener('click', function() {
      voltageData = [];
      currentData = [];
      
      // Reset all monitor stats
      monitorConfigs.forEach(config => {
        monitorStats[config.id] = { sum: 0, count: 0, peak: 0 };
        charts[config.id].data.datasets[0].data = [];
        charts[config.id].update();
      });
      
      // Reset legacy stats for compatibility
      voltageStats = { sum: 0, count: 0, peak: 0 };
      currentStats = { sum: 0, count: 0, peak: 0 };
      
      // Reset displays
      monitorConfigs.forEach(config => {
        const suffix = ` ${config.unit}`;
        elements[config.id].current.textContent = '0.00' + suffix;
        elements[config.id].instantaneous.textContent = '0.00' + suffix;
        elements[config.id].average.textContent = '0.00' + suffix;
        elements[config.id].peak.textContent = '0.00' + suffix;
        elements[config.id].samples.textContent = '0';
      });
    });

    document.getElementById('export-json-btn').addEventListener('click', function() {
      const data = {
        timestamp: new Date().toISOString(),
        voltage_data: voltageData,
        current_data: currentData,
        voltage_stats: voltageStats,
        current_stats: currentStats
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `sensor_data_${new Date().toISOString().slice(0, 19)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });

    document.getElementById('export-csv-btn').addEventListener('click', function() {
      // Create CSV header
      const headers = ['Timestamp', 'Time_Seconds', 'Voltage_V', 'Current_A'];
      
      // Create CSV rows
      const rows = [];
      const maxLength = Math.max(voltageData.length, currentData.length);
      
      for (let i = 0; i < maxLength; i++) {
        const voltagePoint = voltageData[i] || { x: 0, y: 0 };
        const currentPoint = currentData[i] || { x: 0, y: 0 };
        
        // Use the timestamp from voltage data or current data (whichever is available)
        const timeSeconds = voltagePoint.x || currentPoint.x;
        const timestamp = new Date(timeSeconds * 1000).toISOString();
        
        const row = [
          timestamp,
          timeSeconds.toFixed(3),
          voltagePoint.y.toFixed(3),
          currentPoint.y.toFixed(3)
        ];
        
        rows.push(row.join(','));
      }
      
      // Combine header and data
      const csvContent = [headers.join(','), ...rows].join('\n');
      
      // Add summary statistics as comments at the end
      const summaryLines = [
        '',
        '# Summary Statistics',
        `# Voltage - Samples: ${voltageStats.count}, Average: ${(voltageStats.sum / voltageStats.count || 0).toFixed(3)}V, Peak: ${voltageStats.peak.toFixed(3)}V`,
        `# Current - Samples: ${currentStats.count}, Average: ${(currentStats.sum / currentStats.count || 0).toFixed(3)}A, Peak: ${currentStats.peak.toFixed(3)}A`,
        `# Export Date: ${new Date().toISOString()}`
      ];
      
      const finalContent = csvContent + '\n' + summaryLines.join('\n');
      
      // Create and download the file
      const blob = new Blob([finalContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `sensor_data_${new Date().toISOString().slice(0, 19)}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    });

  </script>
</body>
</html>